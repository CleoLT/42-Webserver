//passer le premier arg a la fonction buffer[i + 1]
//verifier le bon nombre d'arg et le ; a la fin
//verifier si le type des args est correct
//parser/transformer les args
//checker le flag si l'arg existe deja ou non et l'ajouter
//checker les doublons de ligne dans le fichier de config
//ajouter aux attributs de la classe associees
//checker si l'arg est valide (port pas ferme, fichier existants ...) ??

//gerer les changements de bloc server et location en changeant leur iterateurs aussi


--> listen <--

//quel port et ip address ecouter pour la connexion

// default ip address: 0.0.0.0
// default port : 80
// socket address : 0.0.0.0:80
//possible many listen on server block only (no location)
//not possible same ip & port address two times
//default one 80 & 0.0.0.0


--> serverName <--

//associer une configuration a un nom de domaine
//ce serveur répondra à telle ou telle URL ou nom de domaine, cela signifie
// que cette config s’appliquera uniquement aux requêtes faites aux args passes

// www.example.com
// www est un label, example est un autre label, com est un autre label

// Chaque label doit respecter les règles DNS:
// Ne contenir que des lettres, chiffres et tirets
// Ne pas commencer ni finir par un tiret
// Avoir une longueur entre 1 et 63 caractères
// Longueur totale du nom ≤ 255 caractères.
//possible many args, check with the DNS standart all 'label' from all args
//can be only one time by server block only (no location)


--> autoindex <--

//contrôle si le serveur doit afficher automatiquement la liste des fichiers
//d’un dossier, quand aucun fichier index (comme index.html) n’est trouvé
//De naviguer visuellement dans les dossiers (comme un explorateur de fichiers).

// 'on'  ->affiche les fichiers du dossier si aucun index trouvé
// 'off' ->	(Défaut) masque les fichiers, renvoie une erreur à la place (403)

//only one by block, only 'on' or 'off' authorized, only one arg


--> root <--

//le chemin de base (dans le système de fichiers) où Nginx va chercher
//les fichiers statics (HTML, CSS, images, JS...) à servir au client

//un seul arg qui commence par "/" (chemin absolu)
//une seule directive par bloc


--> index <--

//sert à définir les fichiers à servir par défaut lorsqu’un client
//accède à un répertoire.

//un ou plusieurs arg
//une seule directive par bloc


--> client_max_body_size <--

//limiter la taille maximale du body d'une requête HTTP
//généralement pour des requêtes POST ou PUT

//un seul arg obligatoire
//une seule directive par bloc
//autorise seulement m/M & k/k colle au chiffre devant

//1k = 1024 octets/bits
//1m = 1024 x 1024 = 1048576 bits
// 1m = 1024k


--> allow_methods <--

//mot-clé dans une requête HTTP qui indique l’intention du client 
//(souvent un navigateur ou un autre programme) envers une ressource

// GET		Récupérer une ressource (lecture)
// POST		Envoyer des données (ex. formulaire)
// DELETE	Supprimer une ressource
// PUT		Remplacer une ressource entière
// PATCH	Modifier partiellement une ressource
// HEAD		Même chose que GET sans le corps de réponse
// OPTIONS	Demander au serveur quelles méthodes sont autorisées

//peut ecrire plusieurs fois la mm methods ds la directive, la methode en doublon est juste ignorer
//on peut mettre une erreur si on le souhaite mais nginx ne le fait pas
// une directive par bloc

--> return <--

//redirectionner ou de retourner immédiatement une réponse HTTP simple
//sans traiter de fichier ou passer par un proxy
//stop tout, et renvoie immédiatement une réponse au client
//TOUTES LES AUTRES INFOS DU BLOC NE SONT PAS PRISES EN COMPTE,il faut les garder mais
// si il y a un return dans un bloc on l'excute TOUT DE SUITE et on oublie tout le reste de ce bloc

//une directive par bloc, 1 ou 2 args, avec un nombre en premier de 100 a 599
//et possiblement un bloc de texte mais pas plus

// return 404;
// return 301 https://example.com;
// return 503 "Service unavailable";

--> error_page <--

//-> client error <-
//400 bad request -> Cleo
//401 unauthorized
//403 forbidden
//404 not found
//405 Method Not Allowed -> Cleo
//410 gone
//413 Request Entity Too Large
//414 URI Too Long -> CLeo

// -> Server error <-
//500 internal server error
//501 Not Implemented -> Cleo

--> TO DO

//passer tout en dynamique

//changer pour parser en deux temps et gerer TOUTES les infos server avant les locations

//si il manque des arguments au fichier comme listen par ex,
//les messages d'erreurs sont au lancement du server pas au parsing

//checker avec Cleo comment garder les errors pages generiques
//juste message ou aussi adresse dans une struct ?

--> TO ASK
//est ce que je dois mettre localhost en arg valide pour listen ?
//mettre les numeros de lignes et les args ?


//chemin absolu = /blabla
//chemin relatif = ./blabla

//test char no printable 
// printf "server\x01{}\n" > ../conf/test.conf
